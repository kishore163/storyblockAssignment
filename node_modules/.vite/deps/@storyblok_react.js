import {
  require_jsx_runtime
} from "./chunk-JD2GUPID.js";
import {
  require_react
} from "./chunk-6ZBOOF7O.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/@storyblok/react/dist/index.mjs
var import_react6 = __toESM(require_react(), 1);

// node_modules/@storyblok/js/dist/storyblok-js.mjs
var ce = Object.defineProperty;
var ue = (e3, t, r2) => t in e3 ? ce(e3, t, { enumerable: true, configurable: true, writable: true, value: r2 }) : e3[t] = r2;
var y = (e3, t, r2) => ue(e3, typeof t != "symbol" ? t + "" : t, r2);
var E = (function(e3) {
  return e3.DOCUMENT = "doc", e3.HEADING = "heading", e3.PARAGRAPH = "paragraph", e3.QUOTE = "blockquote", e3.OL_LIST = "ordered_list", e3.UL_LIST = "bullet_list", e3.LIST_ITEM = "list_item", e3.CODE_BLOCK = "code_block", e3.HR = "horizontal_rule", e3.BR = "hard_break", e3.IMAGE = "image", e3.EMOJI = "emoji", e3.COMPONENT = "blok", e3.TABLE = "table", e3.TABLE_ROW = "tableRow", e3.TABLE_CELL = "tableCell", e3.TABLE_HEADER = "tableHeader", e3;
})({});
var w = (function(e3) {
  return e3.BOLD = "bold", e3.STRONG = "strong", e3.STRIKE = "strike", e3.UNDERLINE = "underline", e3.ITALIC = "italic", e3.CODE = "code", e3.LINK = "link", e3.ANCHOR = "anchor", e3.STYLED = "styled", e3.SUPERSCRIPT = "superscript", e3.SUBSCRIPT = "subscript", e3.TEXT_STYLE = "textStyle", e3.HIGHLIGHT = "highlight", e3;
})({});
var he = (function(e3) {
  return e3.TEXT = "text", e3;
})({});
var x = (function(e3) {
  return e3.URL = "url", e3.STORY = "story", e3.ASSET = "asset", e3.EMAIL = "email", e3;
})({});
var de = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var fe = (e3 = {}) => {
  const { custom: t, ...r2 } = e3, s4 = {
    ...r2,
    ...t
  };
  return Object.keys(s4).map((i6) => `${i6}="${s4[i6]}"`).join(" ");
};
var ge = (e3 = {}) => Object.keys(e3).map((t) => `${t}: ${e3[t]}`).join("; ");
function ye(e3) {
  return e3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
var O = (e3) => Object.fromEntries(Object.entries(e3).filter(([t, r2]) => r2 !== void 0));
function be(e3, t) {
  if (!t) return {
    src: e3,
    attrs: {}
  };
  let r2 = 0, s4 = 0;
  const i6 = {}, n2 = [];
  function l4(u3, c4, b2, m4, R) {
    typeof u3 != "number" || u3 <= c4 || u3 >= b2 ? console.warn(`[StoryblokRichText] - ${m4.charAt(0).toUpperCase() + m4.slice(1)} value must be a number between ${c4} and ${b2} (inclusive)`) : R.push(`${m4}(${u3})`);
  }
  if (typeof t == "object") {
    if (t.width !== void 0 && (typeof t.width == "number" && t.width >= 0 ? (i6.width = t.width, r2 = t.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than or equal to 0")), t.height !== void 0 && (typeof t.height == "number" && t.height >= 0 ? (i6.height = t.height, s4 = t.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than or equal to 0")), t.height === 0 && t.width === 0 && (delete i6.width, delete i6.height, console.warn("[StoryblokRichText] - Width and height values cannot both be 0")), t.loading && ["lazy", "eager"].includes(t.loading) && (i6.loading = t.loading), t.class && (i6.class = t.class), t.filters) {
      const { filters: u3 } = t || {}, { blur: c4, brightness: b2, fill: m4, format: R, grayscale: A, quality: _, rotate: T } = u3 || {};
      c4 && l4(c4, 0, 100, "blur", n2), _ && l4(_, 0, 100, "quality", n2), b2 && l4(b2, 0, 100, "brightness", n2), m4 && n2.push(`fill(${m4})`), A && n2.push("grayscale()"), T && [
        0,
        90,
        180,
        270
      ].includes(t.filters.rotate || 0) && n2.push(`rotate(${T})`), R && [
        "webp",
        "png",
        "jpeg"
      ].includes(R) && n2.push(`format(${R})`);
    }
    t.srcset && (i6.srcset = t.srcset.map((u3) => {
      if (typeof u3 == "number") return `${e3}/m/${u3}x0/${n2.length > 0 ? `filters:${n2.join(":")}` : ""} ${u3}w`;
      if (Array.isArray(u3) && u3.length === 2) {
        const [c4, b2] = u3;
        return `${e3}/m/${c4}x${b2}/${n2.length > 0 ? `filters:${n2.join(":")}` : ""} ${c4}w`;
      } else {
        console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
        return;
      }
    }).join(", ")), t.sizes && (i6.sizes = t.sizes.join(", "));
  }
  let a = `${e3}/m/`;
  return (r2 > 0 || s4 > 0) && (a = `${a}${r2}x${s4}/`), n2.length > 0 && (a = `${a}filters:${n2.join(":")}`), {
    src: a,
    attrs: i6
  };
}
function J(e3, t = {}, r2) {
  const s4 = fe(t), i6 = s4 ? `${e3} ${s4}` : e3, n2 = Array.isArray(r2) ? r2.join("") : r2 || "";
  if (e3) {
    if (de.includes(e3)) return `<${i6}>`;
  } else return n2;
  return `<${i6}>${n2}</${e3}>`;
}
function me(e3 = {}) {
  const t = /* @__PURE__ */ new Map(), { renderFn: r2 = J, textFn: s4 = ye, resolvers: i6 = {}, optimizeImages: n2 = false, keyedResolvers: l4 = false } = e3, a = r2 !== J, u3 = (o3 = {}) => {
    const { textAlign: h3, class: d, id: f3, style: g4, ...v } = o3, p3 = [];
    return g4 && p3.push(g4.endsWith(";") ? g4 : `${g4};`), h3 && p3.push(`text-align: ${h3};`), O({
      ...v,
      class: d,
      id: f3,
      ...p3.length > 0 ? { style: p3.join(" ") } : {}
    });
  }, c4 = (o3) => (h3, d) => {
    const f3 = u3(h3.attrs);
    return d.render(o3, f3, h3.children || null);
  }, b2 = (o3, h3) => {
    const { src: d, alt: f3, title: g4, srcset: v, sizes: p3 } = o3.attrs || {};
    let k4 = d, L = {};
    if (n2) {
      const { src: ae, attrs: le } = be(d, n2);
      k4 = ae, L = le;
    }
    const C2 = {
      src: k4,
      alt: f3,
      title: g4,
      srcset: v,
      sizes: p3,
      ...L
    };
    return h3.render("img", O(C2));
  }, m4 = (o3, h3) => {
    const { level: d, ...f3 } = o3.attrs || {}, g4 = u3(f3);
    return h3.render(`h${d}`, g4, o3.children);
  }, R = (o3, h3) => {
    var f3, g4, v, p3;
    const d = h3.render("img", {
      src: (f3 = o3.attrs) == null ? void 0 : f3.fallbackImage,
      alt: (g4 = o3.attrs) == null ? void 0 : g4.alt,
      style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
      draggable: "false",
      loading: "lazy"
    });
    return h3.render("span", {
      "data-type": "emoji",
      "data-name": (v = o3.attrs) == null ? void 0 : v.name,
      "data-emoji": (p3 = o3.attrs) == null ? void 0 : p3.emoji
    }, d);
  }, A = (o3, h3) => h3.render("pre", o3.attrs || {}, h3.render("code", {}, o3.children || "")), _ = (o3, h3 = false) => ({ text: d, attrs: f3 }, g4) => {
    const { class: v, id: p3, ...k4 } = f3 || {}, L = h3 ? {
      class: v,
      id: p3,
      style: ge(k4) || void 0
    } : f3 || {};
    return g4.render(o3, O(L), d);
  }, T = (o3) => $(o3), U = (o3) => {
    const { marks: h3, ...d } = o3;
    if ("text" in o3) {
      if (h3) return h3.reduce((g4, v) => T({
        ...v,
        text: g4
      }), T({
        ...d,
        children: d.children
      }));
      const f3 = o3.attrs || {};
      if (l4) {
        const g4 = t.get("txt") || 0;
        t.set("txt", g4 + 1), f3.key = `txt-${g4}`;
      }
      return s4(d.text, f3);
    }
    return "";
  }, z = (o3, h3) => {
    const { linktype: d, href: f3, anchor: g4, ...v } = o3.attrs || {};
    let p3 = "";
    switch (d) {
      case x.ASSET:
      case x.URL:
        p3 = f3;
        break;
      case x.EMAIL:
        p3 = `mailto:${f3}`;
        break;
      case x.STORY:
        p3 = f3, g4 && (p3 = `${p3}#${g4}`);
        break;
      default:
        p3 = f3;
        break;
    }
    const k4 = { ...v };
    return p3 && (k4.href = p3), h3.render("a", k4, o3.text);
  }, te = (o3, h3) => {
    var d, f3;
    return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"), h3.render("span", {
      blok: (d = o3 == null ? void 0 : o3.attrs) == null ? void 0 : d.body[0],
      id: (f3 = o3.attrs) == null ? void 0 : f3.id,
      style: "display: none"
    });
  }, re = (o3, h3) => {
    const d = u3(o3.attrs), f3 = o3.children || null;
    return h3.render("table", d, h3.render("tbody", {}, f3));
  }, se = (o3, h3) => {
    const d = u3(o3.attrs);
    return h3.render("tr", d, o3.children);
  }, ie = (o3, h3) => {
    const { colspan: d, rowspan: f3, colwidth: g4, backgroundColor: v, textAlign: p3, ...k4 } = o3.attrs || {}, L = [];
    g4 && L.push(`width: ${g4}px;`), v && L.push(`background-color: ${v};`), p3 && L.push(`text-align: ${p3};`);
    const C2 = {
      ...k4,
      ...d > 1 ? { colspan: d } : {},
      ...f3 > 1 ? { rowspan: f3 } : {},
      ...L.length > 0 ? { style: L.join(" ") } : {}
    };
    return h3.render("td", O(C2), o3.children);
  }, ne = (o3, h3) => {
    const { colspan: d, rowspan: f3, colwidth: g4, backgroundColor: v, textAlign: p3, ...k4 } = o3.attrs || {}, L = [];
    g4 && L.push(`width: ${g4}px;`), v && L.push(`background-color: ${v};`), p3 && L.push(`text-align: ${p3};`);
    const C2 = {
      ...k4,
      ...d > 1 ? { colspan: d } : {},
      ...f3 > 1 ? { rowspan: f3 } : {},
      ...L.length > 0 ? { style: L.join(" ") } : {}
    };
    return h3.render("th", O(C2), o3.children);
  }, V = /* @__PURE__ */ new Map([
    [E.DOCUMENT, c4("")],
    [E.HEADING, m4],
    [E.PARAGRAPH, c4("p")],
    [E.UL_LIST, c4("ul")],
    [E.OL_LIST, c4("ol")],
    [E.LIST_ITEM, c4("li")],
    [E.IMAGE, b2],
    [E.EMOJI, R],
    [E.CODE_BLOCK, A],
    [E.HR, c4("hr")],
    [E.BR, c4("br")],
    [E.QUOTE, c4("blockquote")],
    [E.COMPONENT, te],
    [he.TEXT, U],
    [w.LINK, z],
    [w.ANCHOR, z],
    [w.STYLED, _("span", true)],
    [w.BOLD, _("strong")],
    [w.TEXT_STYLE, _("span", true)],
    [w.ITALIC, _("em")],
    [w.UNDERLINE, _("u")],
    [w.STRIKE, _("s")],
    [w.CODE, _("code")],
    [w.SUPERSCRIPT, _("sup")],
    [w.SUBSCRIPT, _("sub")],
    [w.HIGHLIGHT, _("mark")],
    [E.TABLE, re],
    [E.TABLE_ROW, se],
    [E.TABLE_CELL, ie],
    [E.TABLE_HEADER, ne]
  ]), Y = new Map([...V, ...Object.entries(i6).map(([o3, h3]) => [o3, h3])]), oe = () => ({
    render: (d, f3 = {}, g4) => {
      if (l4 && d) {
        const v = t.get(d) || 0;
        t.set(d, v + 1), f3.key = `${d}-${v}`;
      }
      return r2(d, f3, g4);
    },
    originalResolvers: V,
    mergedResolvers: Y
  });
  function P(o3) {
    const h3 = Y.get(o3.type);
    if (!h3)
      return console.error("<Storyblok>", `No resolver found for node type ${o3.type}`), "";
    const d = oe();
    if (o3.type === "text") return h3(o3, d);
    const f3 = o3.content ? o3.content.map($) : void 0;
    return h3({
      ...o3,
      children: f3
    }, d);
  }
  function $(o3) {
    return o3.type === "doc" ? a ? o3.content.map(P) : o3.content.map(P).join("") : Array.isArray(o3) ? o3.map(P) : P(o3);
  }
  return { render: $ };
}
var K = false;
var W = [];
var Z = (e3) => new Promise((t, r2) => {
  if (typeof window > "u") {
    r2(new Error("Cannot load Storyblok bridge: window is undefined (server-side environment)"));
    return;
  }
  if (window.storyblokRegisterEvent = (i6) => {
    if (!window.location.search.includes("_storyblok")) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    K ? i6() : W.push(i6);
  }, document.getElementById("storyblok-javascript-bridge")) {
    t(void 0);
    return;
  }
  const s4 = document.createElement("script");
  s4.async = true, s4.src = e3, s4.id = "storyblok-javascript-bridge", s4.onerror = (i6) => r2(i6), s4.onload = (i6) => {
    W.forEach((n2) => n2()), K = true, t(i6);
  }, document.getElementsByTagName("head")[0].appendChild(s4);
});
var j = (e3 = "") => e3.includes("/cdn/");
var pe = (e3, t = 25, r2 = 1) => ({
  ...e3,
  per_page: t,
  page: r2
});
var Re = (e3) => new Promise((t) => setTimeout(t, e3));
var ve = (e3 = 0, t) => Array.from({ length: e3 }, t);
var _e = (e3 = 0, t = e3) => {
  const r2 = Math.abs(t - e3) || 0, s4 = e3 < t ? 1 : -1;
  return ve(r2, (i6, n2) => n2 * s4 + e3);
};
var Ee = async (e3, t) => Promise.all(e3.map(t));
var Ae = (e3 = [], t) => e3.map(t).reduce((r2, s4) => [...r2, ...s4], []);
var B = (e3, t, r2) => {
  const s4 = [];
  for (const i6 in e3) {
    if (!Object.prototype.hasOwnProperty.call(e3, i6)) continue;
    const n2 = e3[i6];
    if (n2 == null) continue;
    const l4 = r2 ? "" : encodeURIComponent(i6);
    let a;
    typeof n2 == "object" ? a = B(n2, t ? t + encodeURIComponent(`[${l4}]`) : l4, Array.isArray(n2)) : a = `${t ? t + encodeURIComponent(`[${l4}]`) : l4}=${encodeURIComponent(n2)}`, s4.push(a);
  }
  return s4.join("&");
};
var Q = (e3) => {
  const t = {
    eu: "api.storyblok.com",
    us: "api-us.storyblok.com",
    cn: "app.storyblokchina.cn",
    ap: "api-ap.storyblok.com",
    ca: "api-ca.storyblok.com"
  };
  return t[e3] ?? t.eu;
};
var Le = class {
  constructor(e3) {
    y(this, "baseURL");
    y(this, "timeout");
    y(this, "headers");
    y(this, "responseInterceptor");
    y(this, "fetch");
    y(this, "ejectInterceptor");
    y(this, "url");
    y(this, "parameters");
    y(this, "fetchOptions");
    this.baseURL = e3.baseURL, this.headers = e3.headers || new Headers(), this.timeout = e3 != null && e3.timeout ? e3.timeout * 1e3 : 0, this.responseInterceptor = e3.responseInterceptor, this.fetch = (...t) => e3.fetch ? e3.fetch(...t) : fetch(...t), this.ejectInterceptor = false, this.url = "", this.parameters = {}, this.fetchOptions = {};
  }
  /**
  *
  * @param url string
  * @param params ISbStoriesParams
  * @returns Promise<ISbResponse | Error>
  */
  get(e3, t) {
    return this.url = e3, this.parameters = t, this._methodHandler("get");
  }
  post(e3, t) {
    return this.url = e3, this.parameters = t, this._methodHandler("post");
  }
  put(e3, t) {
    return this.url = e3, this.parameters = t, this._methodHandler("put");
  }
  delete(e3, t) {
    return this.url = e3, this.parameters = t ?? {}, this._methodHandler("delete");
  }
  async _responseHandler(e3) {
    const t = [], r2 = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    e3.status !== 204 && await e3.json().then((s4) => {
      r2.data = s4;
    });
    for (const s4 of e3.headers.entries()) t[s4[0]] = s4[1];
    return r2.headers = { ...t }, r2.status = e3.status, r2.statusText = e3.statusText, r2;
  }
  async _methodHandler(e3) {
    let t = `${this.baseURL}${this.url}`, r2 = null;
    e3 === "get" ? t = `${this.baseURL}${this.url}?${B(this.parameters)}` : r2 = JSON.stringify(this.parameters);
    const s4 = new URL(t), i6 = new AbortController(), { signal: n2 } = i6;
    let l4 = null;
    this.timeout && (l4 = setTimeout(() => i6.abort(), this.timeout));
    try {
      const a = await this.fetch(`${s4}`, {
        method: e3,
        headers: this.headers,
        body: r2,
        signal: n2,
        ...this.fetchOptions
      });
      this.timeout && l4 && clearTimeout(l4);
      const u3 = await this._responseHandler(a);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(u3)) : this._statusHandler(u3);
    } catch (a) {
      return { message: a };
    }
  }
  setFetchOptions(e3 = {}) {
    Object.keys(e3).length > 0 && "method" in e3 && delete e3.method, this.fetchOptions = { ...e3 };
  }
  eject() {
    this.ejectInterceptor = true;
  }
  /**
  * Normalizes error messages from different response structures
  * @param data The response data that might contain error information
  * @returns A normalized error message string
  */
  _normalizeErrorMessage(e3) {
    if (Array.isArray(e3)) return e3[0] || "Unknown error";
    if (e3 && typeof e3 == "object") {
      if (e3.error) return e3.error;
      for (const t in e3) {
        if (Array.isArray(e3[t])) return `${t}: ${e3[t][0]}`;
        if (typeof e3[t] == "string") return `${t}: ${e3[t]}`;
      }
      if (e3.slug) return e3.slug;
    }
    return "Unknown error";
  }
  _statusHandler(e3) {
    const t = /20[0-6]/g;
    return new Promise((r2, s4) => {
      if (t.test(`${e3.status}`)) return r2(e3);
      const i6 = {
        message: this._normalizeErrorMessage(e3.data),
        status: e3.status,
        response: e3
      };
      s4(i6);
    });
  }
};
var we = Le;
var X = "SB-Agent";
var G = {
  defaultAgentName: "SB-JS-CLIENT",
  defaultAgentVersion: "SB-Agent-Version",
  packageVersion: "7.0.0"
};
var ee = {
  DRAFT: "draft",
  PUBLISHED: "published"
};
var ke = 25;
var q = {
  SMALL: 25,
  MEDIUM: 50,
  LARGE: 75
};
var I = {
  SINGLE_OR_SMALL: 50,
  MEDIUM: 15,
  LARGE: 10,
  VERY_LARGE: 6
};
var F = 1e3;
var N = 3;
function Se(e3) {
  return e3.version === ee.DRAFT;
}
function Te(e3, t) {
  const r2 = e3.includes("/cdn/stories/"), s4 = e3.split("/").length > 3 && !e3.endsWith("/cdn/stories"), i6 = "find_by" in t;
  return r2 && s4 || i6;
}
function Ce(e3) {
  return e3 <= q.SMALL ? I.SINGLE_OR_SMALL : e3 <= q.MEDIUM ? I.MEDIUM : e3 <= q.LARGE ? I.LARGE : I.VERY_LARGE;
}
function H(e3, t, r2 = {}, s4) {
  if (r2.userRateLimit !== void 0) return Math.min(r2.userRateLimit, F);
  if (r2.serverHeadersRateLimit !== void 0) return Math.min(r2.serverHeadersRateLimit, F);
  if (s4 !== void 0) return s4;
  if (t && !Se(t)) return F;
  if (Te(e3, t)) return I.SINGLE_OR_SMALL;
  const i6 = t.per_page || ke;
  return Ce(i6);
}
function Oe(e3) {
  if (!e3) return null;
  const t = e3["x-ratelimit"] || e3["X-RateLimit"], r2 = e3["x-ratelimit-policy"] || e3["X-RateLimit-Policy"];
  if (!t && !r2) return null;
  const s4 = {};
  if (t) {
    const i6 = t.match(/r=(\d+)/);
    i6 && (s4.remaining = Number.parseInt(i6[1], 10));
  }
  if (r2) {
    const i6 = r2.match(/q=(\d+)/);
    i6 && (s4.max = Number.parseInt(i6[1], 10));
  }
  return Object.keys(s4).length > 0 ? s4 : null;
}
function Ie(e3, t = false) {
  return {
    userRateLimit: e3,
    serverHeadersRateLimit: void 0,
    isManagementApi: t
  };
}
var Pe = class extends Error {
  constructor(e3) {
    super(e3), this.name = "AbortError";
  }
};
function xe(e3, t, r2) {
  if (!Number.isFinite(t)) throw new TypeError("Expected `limit` to be a finite number");
  if (!Number.isFinite(r2)) throw new TypeError("Expected `interval` to be a finite number");
  const s4 = [];
  let i6 = [], n2 = 0, l4 = false;
  const a = async () => {
    n2++;
    const c4 = s4.shift();
    if (c4) try {
      const m4 = await e3(...c4.args);
      c4.resolve(m4);
    } catch (m4) {
      c4.reject(m4);
    }
    const b2 = setTimeout(() => {
      n2--, s4.length > 0 && a(), i6 = i6.filter((m4) => m4 !== b2);
    }, r2);
    i6.includes(b2) || i6.push(b2);
  }, u3 = (...c4) => l4 ? Promise.reject(new Error("Throttled function is already aborted and not accepting new promises")) : new Promise((b2, m4) => {
    s4.push({
      resolve: b2,
      reject: m4,
      args: c4
    }), n2 < t && a();
  });
  return u3.abort = () => {
    l4 = true, i6.forEach(clearTimeout), i6 = [], s4.forEach((c4) => c4.reject(() => new Pe("Throttle function aborted"))), s4.length = 0;
  }, u3;
}
var Ne = xe;
var He = class {
  constructor(e3, t = 1e3) {
    y(this, "queues");
    y(this, "interval");
    y(this, "throttledRequestFn");
    this.queues = /* @__PURE__ */ new Map(), this.interval = t, this.throttledRequestFn = e3;
  }
  /**
  * Gets or creates a throttle queue for the specified rate limit
  */
  getQueue(e3) {
    let t = this.queues.get(e3);
    return t || (t = Ne(this.throttledRequestFn, e3, this.interval), this.queues.set(e3, t)), t;
  }
  /**
  * Executes a request through the appropriate throttle queue based on rate limit
  */
  execute(e3, ...t) {
    return this.getQueue(e3)(...t);
  }
  /**
  * Aborts all throttle queues
  */
  abortAll() {
    this.queues.forEach((e3) => {
      var t;
      (t = e3.abort) == null || t.call(e3);
    }), this.queues.clear();
  }
  /**
  * Gets the number of active queues
  */
  getQueueCount() {
    return this.queues.size;
  }
};
var M = {};
var S = {};
var Me = class {
  /**
  *
  * @param config ISbConfig interface
  * @param pEndpoint string, optional
  */
  constructor(e3, t) {
    y(this, "client");
    y(this, "maxRetries");
    y(this, "retriesDelay");
    y(this, "throttleManager");
    y(this, "accessToken");
    y(this, "cache");
    y(this, "resolveCounter");
    y(this, "relations");
    y(this, "links");
    y(this, "version");
    y(this, "rateLimitConfig");
    y(this, "richTextResolver");
    y(this, "resolveNestedRelations");
    y(this, "stringifiedStoriesCache");
    y(this, "inlineAssets");
    let r2 = e3.endpoint || t;
    if (!r2) {
      const i6 = e3.https === false ? "http" : "https";
      e3.oauthToken ? r2 = `${i6}://${Q(e3.region)}/v1` : r2 = `${i6}://${Q(e3.region)}/v2`;
    }
    const s4 = new Headers();
    s4.set("Content-Type", "application/json"), s4.set("Accept", "application/json"), e3.headers && (e3.headers.constructor.name === "Headers" ? e3.headers.entries().toArray() : Object.entries(e3.headers)).forEach(([n2, l4]) => {
      s4.set(n2, l4);
    }), s4.has(X) || (s4.set(X, G.defaultAgentName), s4.set(G.defaultAgentVersion, G.packageVersion)), e3.oauthToken && s4.set("Authorization", e3.oauthToken), this.rateLimitConfig = Ie(e3.rateLimit, !!e3.oauthToken), this.maxRetries = e3.maxRetries || 10, this.retriesDelay = 300, this.throttleManager = new He(this.throttledRequest.bind(this), 1e3), this.accessToken = e3.accessToken || "", this.relations = {}, this.links = {}, this.cache = e3.cache || { clear: "manual" }, this.resolveCounter = 0, this.resolveNestedRelations = e3.resolveNestedRelations || true, this.stringifiedStoriesCache = {}, this.version = e3.version || ee.PUBLISHED, this.inlineAssets = e3.inlineAssets || false, this.client = new we({
      baseURL: r2,
      timeout: e3.timeout || 0,
      headers: s4,
      responseInterceptor: e3.responseInterceptor,
      fetch: e3.fetch
    });
  }
  parseParams(e3) {
    return e3.token || (e3.token = this.getToken()), e3.cv || (e3.cv = S[e3.token]), Array.isArray(e3.resolve_relations) && (e3.resolve_relations = e3.resolve_relations.join(",")), typeof e3.resolve_relations < "u" && (e3.resolve_level = 2), e3;
  }
  factoryParamOptions(e3, t) {
    return j(e3) ? this.parseParams(t) : t;
  }
  makeRequest(e3, t, r2, s4, i6) {
    const n2 = this.factoryParamOptions(e3, pe(t, r2, s4));
    return this.cacheResponse(e3, n2, void 0, i6);
  }
  get(e3, t = {}, r2) {
    t || (t = {});
    const s4 = `/${e3}`;
    j(s4) && (t.version = t.version || this.version);
    const i6 = this.factoryParamOptions(s4, t);
    return this.cacheResponse(s4, i6, void 0, r2);
  }
  async getAll(e3, t = {}, r2, s4) {
    const i6 = (t == null ? void 0 : t.per_page) || 25, n2 = `/${e3}`.replace(/\/$/, ""), l4 = r2 ?? n2.substring(n2.lastIndexOf("/") + 1);
    t.version = t.version || this.version;
    const a = 1, u3 = await this.makeRequest(n2, t, i6, a, s4), c4 = u3.total ? Math.ceil(u3.total / (u3.perPage || i6)) : 1, b2 = await Ee(_e(a, c4), (m4) => this.makeRequest(n2, t, i6, m4 + 1, s4));
    return Ae([u3, ...b2], (m4) => Object.values(m4.data[l4]));
  }
  post(e3, t = {}, r2) {
    const s4 = `/${e3}`, i6 = H(void 0, void 0, this.rateLimitConfig, N);
    return this.throttleManager.execute(i6, "post", s4, t, r2);
  }
  put(e3, t = {}, r2) {
    const s4 = `/${e3}`, i6 = H(void 0, void 0, this.rateLimitConfig, N);
    return this.throttleManager.execute(i6, "put", s4, t, r2);
  }
  delete(e3, t = {}, r2) {
    t || (t = {});
    const s4 = `/${e3}`, i6 = H(void 0, void 0, this.rateLimitConfig, N);
    return this.throttleManager.execute(i6, "delete", s4, t, r2);
  }
  getStories(e3 = {}, t) {
    return this._addResolveLevel(e3), this.get("cdn/stories", e3, t);
  }
  getStory(e3, t = {}, r2) {
    return this._addResolveLevel(t), this.get(`cdn/stories/${e3}`, t, r2);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _addResolveLevel(e3) {
    typeof e3.resolve_relations < "u" && (e3.resolve_level = 2);
  }
  _cleanCopy(e3) {
    return JSON.parse(JSON.stringify(e3));
  }
  _insertLinks(e3, t, r2) {
    const s4 = e3[t];
    s4 && s4.fieldtype === "multilink" && s4.linktype === "story" && typeof s4.id == "string" && this.links[r2][s4.id] ? s4.story = this._cleanCopy(this.links[r2][s4.id]) : s4 && s4.linktype === "story" && typeof s4.uuid == "string" && this.links[r2][s4.uuid] && (s4.story = this._cleanCopy(this.links[r2][s4.uuid]));
  }
  /**
  *
  * @param resolveId A counter number as a string
  * @param uuid The uuid of the story
  * @returns string | object
  */
  getStoryReference(e3, t) {
    return this.relations[e3][t] ? JSON.parse(this.stringifiedStoriesCache[t] || JSON.stringify(this.relations[e3][t])) : t;
  }
  /**
  * Resolves a field's value by replacing UUIDs with their corresponding story references
  * @param jtree - The JSON tree object containing the field to resolve
  * @param treeItem - The key of the field to resolve
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles both single string UUIDs and arrays of UUIDs:
  * - For single strings: directly replaces the UUID with the story reference
  * - For arrays: maps through each UUID and replaces with corresponding story references
  */
  _resolveField(e3, t, r2) {
    const s4 = e3[t];
    typeof s4 == "string" ? e3[t] = this.getStoryReference(r2, s4) : Array.isArray(s4) && (e3[t] = s4.map((i6) => this.getStoryReference(r2, i6)).filter(Boolean));
  }
  /**
  * Inserts relations into the JSON tree by resolving references
  * @param jtree - The JSON tree object to process
  * @param treeItem - The current field being processed
  * @param fields - The relation patterns to resolve (string or array of strings)
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles two types of relation patterns:
  * 1. Nested relations: matches fields that end with the current field name
  *    Example: If treeItem is "event_type", it matches patterns like "*.event_type"
  *
  * 2. Direct component relations: matches exact component.field patterns
  *    Example: "event.event_type" for component "event" and field "event_type"
  *
  * The method supports both string and array formats for the fields parameter,
  * allowing flexible specification of relation patterns.
  */
  _insertRelations(e3, t, r2, s4) {
    if (Array.isArray(r2) ? r2.find((l4) => l4.endsWith(`.${t}`)) : r2.endsWith(`.${t}`)) {
      this._resolveField(e3, t, s4);
      return;
    }
    const n2 = e3.component ? `${e3.component}.${t}` : t;
    (Array.isArray(r2) ? r2.includes(n2) : r2 === n2) && this._resolveField(e3, t, s4);
  }
  /**
  * Recursively traverses and resolves relations in the story content tree
  * @param story - The story object containing the content to process
  * @param fields - The relation patterns to resolve
  * @param resolveId - The unique identifier for the current resolution context
  */
  iterateTree(e3, t, r2) {
    const s4 = (i6, n2 = "") => {
      if (!(!i6 || i6._stopResolving)) {
        if (Array.isArray(i6)) i6.forEach((l4, a) => s4(l4, `${n2}[${a}]`));
        else if (typeof i6 == "object") for (const l4 in i6) {
          const a = n2 ? `${n2}.${l4}` : l4;
          (i6.component && i6._uid || i6.type === "link") && (this._insertRelations(i6, l4, t, r2), this._insertLinks(i6, l4, r2)), s4(i6[l4], a);
        }
      }
    };
    s4(e3.content);
  }
  async resolveLinks(e3, t, r2) {
    let s4 = [];
    if (e3.link_uuids) {
      const i6 = e3.link_uuids.length, n2 = [], l4 = 50;
      for (let a = 0; a < i6; a += l4) {
        const u3 = Math.min(i6, a + l4);
        n2.push(e3.link_uuids.slice(a, u3));
      }
      for (let a = 0; a < n2.length; a++)
        (await this.getStories({
          per_page: l4,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: n2[a].join(",")
        })).data.stories.forEach((c4) => {
          s4.push(c4);
        });
    } else s4 = e3.links;
    s4.forEach((i6) => {
      this.links[r2][i6.uuid] = {
        ...i6,
        _stopResolving: true
      };
    });
  }
  async resolveRelations(e3, t, r2) {
    let s4 = [];
    if (e3.rel_uuids) {
      const i6 = e3.rel_uuids.length, n2 = [], l4 = 50;
      for (let a = 0; a < i6; a += l4) {
        const u3 = Math.min(i6, a + l4);
        n2.push(e3.rel_uuids.slice(a, u3));
      }
      for (let a = 0; a < n2.length; a++)
        (await this.getStories({
          per_page: l4,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: n2[a].join(","),
          excluding_fields: t.excluding_fields
        })).data.stories.forEach((c4) => {
          s4.push(c4);
        });
      s4.length > 0 && (e3.rels = s4, delete e3.rel_uuids);
    } else s4 = e3.rels;
    s4 && s4.length > 0 && s4.forEach((i6) => {
      this.relations[r2][i6.uuid] = {
        ...i6,
        _stopResolving: true
      };
    });
  }
  /**
  *
  * @param responseData
  * @param params
  * @param resolveId
  * @description Resolves the relations and links of the stories
  * @returns Promise<void>
  *
  */
  async resolveStories(e3, t, r2) {
    var i6, n2;
    let s4 = [];
    if (this.links[r2] = {}, this.relations[r2] = {}, typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == "string" && (s4 = t.resolve_relations.split(",")), await this.resolveRelations(e3, t, r2)), t.resolve_links && [
      "1",
      "story",
      "url",
      "link"
    ].includes(t.resolve_links) && ((i6 = e3.links) != null && i6.length || (n2 = e3.link_uuids) != null && n2.length) && await this.resolveLinks(e3, t, r2), this.resolveNestedRelations) for (const l4 in this.relations[r2]) this.iterateTree(this.relations[r2][l4], s4, r2);
    e3.story ? this.iterateTree(e3.story, s4, r2) : e3.stories.forEach((l4) => {
      this.iterateTree(l4, s4, r2);
    }), this.stringifiedStoriesCache = {}, delete this.links[r2], delete this.relations[r2];
  }
  async cacheResponse(e3, t, r2, s4) {
    const i6 = B({
      url: e3,
      params: t
    }), n2 = this.cacheProvider();
    if (t.version === "published" && e3 !== "/cdn/spaces/me") {
      const c4 = await n2.get(i6);
      if (c4) return Promise.resolve(c4);
    }
    const a = !j(e3) && this.rateLimitConfig.isManagementApi ? N : void 0, u3 = H(e3, t, this.rateLimitConfig, a);
    return new Promise(async (c4, b2) => {
      var m4;
      try {
        const R = await this.throttleManager.execute(u3, "get", e3, t, s4);
        if (R.status !== 200) return b2(R);
        let A = {
          data: R.data,
          headers: R.headers
        };
        const _ = Oe(R.headers);
        if ((_ == null ? void 0 : _.max) !== void 0 && (this.rateLimitConfig.serverHeadersRateLimit = _.max), (m4 = R.headers) != null && m4["per-page"] && (A = Object.assign({}, A, {
          perPage: R.headers["per-page"] ? Number.parseInt(R.headers["per-page"]) : 0,
          total: R.headers["per-page"] ? Number.parseInt(R.headers.total) : 0
        })), A.data.story || A.data.stories) {
          const U = this.resolveCounter = ++this.resolveCounter % 1e3;
          await this.resolveStories(A.data, t, `${U}`), A = await this.processInlineAssets(A);
        }
        t.version === "published" && e3 !== "/cdn/spaces/me" && await n2.set(i6, A);
        const T = this.cache.clear === "onpreview" && t.version === "draft" || this.cache.clear === "auto";
        return t.token && A.data.cv && (T && S[t.token] && S[t.token] !== A.data.cv && await this.flushCache(), S[t.token] = A.data.cv), c4(A);
      } catch (R) {
        if (R.response && R.status === 429 && (r2 = typeof r2 > "u" ? 0 : r2 + 1, r2 < this.maxRetries))
          return console.log(`Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`), await Re(this.retriesDelay), this.cacheResponse(e3, t, r2).then(c4).catch(b2);
        b2(R);
      }
    });
  }
  throttledRequest(e3, t, r2, s4) {
    return this.client.setFetchOptions(s4), this.client[e3](t, r2);
  }
  cacheVersions() {
    return S;
  }
  cacheVersion() {
    return S[this.accessToken];
  }
  setCacheVersion(e3) {
    this.accessToken && (S[this.accessToken] = e3);
  }
  clearCacheVersion() {
    this.accessToken && (S[this.accessToken] = 0);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e3) {
            return Promise.resolve(M[e3]);
          },
          getAll() {
            return Promise.resolve(M);
          },
          set(e3, t) {
            return M[e3] = t, Promise.resolve(void 0);
          },
          flush() {
            return M = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom) return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this.clearCacheVersion(), this;
  }
  async processInlineAssets(e3) {
    if (!this.inlineAssets) return e3;
    const t = (r2) => {
      if (!r2 || typeof r2 != "object") return r2;
      if (Array.isArray(r2)) return r2.map((i6) => t(i6));
      let s4 = { ...r2 };
      s4.fieldtype === "asset" && Array.isArray(e3.data.assets) && (s4 = {
        ...e3.data.assets.find((i6) => i6.id === s4.id),
        ...s4
      });
      for (const i6 in s4) typeof s4[i6] == "object" && (s4[i6] = t(s4[i6]));
      return s4;
    };
    return e3.data.story && (e3.data.story.content = t(e3.data.story.content)), e3.data.stories && (e3.data.stories = e3.data.stories.map((r2) => (r2.content = t(r2.content), r2))), e3;
  }
};
var Ue = Me;
var je = (e3 = {}) => {
  const { apiOptions: t } = e3;
  if (!t || !t.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new Ue(t) };
};
var Ge = (e3) => {
  if (typeof e3 != "object" || typeof e3._editable > "u")
    return {};
  try {
    const t = JSON.parse(
      e3._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
    );
    return t ? {
      "data-blok-c": JSON.stringify(t),
      "data-blok-uid": `${t.id}-${t.uid}`
    } : {};
  } catch {
    return {};
  }
};
var D = "https://app.storyblok.com/f/storyblok-v2-latest.js";
var qe = (e3, t, r2 = {}) => {
  var a;
  const i6 = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u", n2 = new URL((a = window.location) == null ? void 0 : a.href).searchParams.get(
    "_storyblok"
  ), l4 = n2 !== null && +n2 === e3;
  if (!(!i6 || !l4)) {
    if (!e3) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(r2).on(["input", "published", "change"], (c4) => {
        var b2;
        c4 && (c4.action === "input" && ((b2 = c4.story) == null ? void 0 : b2.id) === e3 ? t(c4.story) : (c4.action === "change" || c4.action === "published") && c4.storyId === e3 && window.location.reload());
      });
    });
  }
};
var Fe = (e3 = {}) => {
  var b2, m4;
  const {
    bridge: t,
    accessToken: r2,
    use: s4 = [],
    apiOptions: i6 = {},
    bridgeUrl: n2
  } = e3;
  i6.accessToken = i6.accessToken || r2;
  const l4 = { bridge: t, apiOptions: i6 };
  let a = {};
  s4.forEach((R) => {
    a = { ...a, ...R(l4) };
  }), n2 && (D = n2);
  const c4 = !(typeof window > "u") && ((m4 = (b2 = window.location) == null ? void 0 : b2.search) == null ? void 0 : m4.includes("_storyblok_tk"));
  return t !== false && c4 && Z(D), a;
};
function De(e3, t) {
  return me(t).render(e3);
}
var Be = () => Z(D);

// node_modules/@storyblok/react/dist/core/state.mjs
var o = null;
var n = /* @__PURE__ */ new Map();
var e = false;
var s = null;
globalThis.storyCache = globalThis.storyCache || /* @__PURE__ */ new Map();
var c = () => o;
var r = (t) => {
  o = t;
};
var b = (t) => (Object.entries(t).forEach(([l4, a]) => {
  n.set(l4, a);
}), n);
var p = (t) => n.has(t) ? n.get(t) : (console.error(`Component ${t} doesn't exist.`), false);
var C = () => e;
var m = (t) => {
  e = t;
};
var k = () => s;
var i = (t) => {
  s = t;
};

// node_modules/@storyblok/react/dist/core/init.mjs
var k2 = (o3 = {}) => {
  const t = c();
  if (t)
    return () => t;
  const { storyblokApi: e3 } = Fe(o3);
  return r(e3), o3.components && b(o3.components), o3.enableFallbackComponent !== void 0 && m(o3.enableFallbackComponent), o3.customFallbackComponent && i(o3.customFallbackComponent), () => e3;
};

// node_modules/@storyblok/react/dist/core/use-storyblok-api.mjs
var e2 = () => {
  const o3 = c();
  return o3 || console.error(
    "You can't use getStoryblokApi if you're not loading apiPlugin."
  ), o3;
};

// node_modules/@storyblok/react/dist/core/storyblok-component.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
var s2 = (0, import_react.forwardRef)(
  ({ blok: e3, ...t }, p3) => {
    if (!e3)
      return console.error(
        "Please provide a 'blok' property to the StoryblokComponent"
      ), (0, import_jsx_runtime.jsx)("div", { children: "Please provide a blok property to the StoryblokComponent" });
    const n2 = p(e3.component);
    if (n2)
      return (0, import_jsx_runtime.jsx)(n2, { ref: p3, blok: e3, ...t });
    if (C()) {
      const r2 = k();
      return r2 ? (0, import_jsx_runtime.jsx)(r2, { blok: e3, ...t }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsxs)("p", { children: [
        "Component could not be found for blok",
        " ",
        (0, import_jsx_runtime.jsx)("strong", { children: e3.component }),
        "! Is it configured correctly?"
      ] }) });
    }
    return (0, import_jsx_runtime.jsx)("div", {});
  }
);
s2.displayName = "StoryblokComponent";

// node_modules/@storyblok/react/dist/core/use-storyblok-state.mjs
var import_react2 = __toESM(require_react(), 1);
var g = (t = null, n2 = {}) => {
  const [r2, o3] = (0, import_react2.useState)(null), e3 = (t == null ? void 0 : t.id) ?? null;
  return (0, import_react2.useEffect)(() => {
    o3(null);
  }, [e3]), (0, import_react2.useEffect)(() => {
    !(typeof window < "u" && typeof window.storyblokRegisterEvent < "u") || !e3 || qe(
      e3,
      (d) => o3(d),
      n2
    );
  }, [e3, n2]), r2 && r2.id === e3 ? r2 : t;
};

// node_modules/@storyblok/react/dist/core/richtext-hoc.mjs
var import_react3 = __toESM(require_react(), 1);
function y2(c4, {
  isServerContext: t = false
} = {}) {
  return function(e3) {
    var o3, n2;
    const r2 = (o3 = e3 == null ? void 0 : e3.attrs) == null ? void 0 : o3.body;
    if (!Array.isArray(r2) || r2.length === 0)
      return [];
    const a = ((n2 = e3.attrs) == null ? void 0 : n2.id) || (t ? `fallback-key-${JSON.stringify(e3.attrs)}` : void 0);
    return r2.map(
      (i6, m4) => import_react3.default.createElement(c4, {
        blok: i6,
        key: `${a}-${m4}`
      })
    );
  };
}
function k3(c4, {
  isServerContext: t = false
} = {}) {
  return function(e3) {
    const r2 = y2(c4, { isServerContext: t }), { resolvers: a, ...o3 } = e3, n2 = {
      ...t ? e3 : {},
      renderFn: import_react3.default.createElement,
      textFn: (i6) => import_react3.default.createElement(import_react3.default.Fragment, {
        key: Math.random().toString(36).substring(2, 15)
      }, i6),
      resolvers: {
        [E.COMPONENT]: r2,
        ...a
      },
      keyedResolvers: true,
      ...t ? {} : o3
    };
    return me(n2);
  };
}

// node_modules/@storyblok/react/dist/richtext.mjs
var i4 = k3(s2, {
  isServerContext: false
});

// node_modules/@storyblok/react/dist/storyblok-rich-text.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);

// node_modules/@storyblok/react/dist/utils.mjs
var import_react4 = __toESM(require_react(), 1);
function u(e3) {
  return e3.replace(/-([a-z])/g, (o3) => o3[1].toUpperCase());
}
function f(e3) {
  return e3.split(";").reduce((o3, i6) => {
    let [t, n2] = i6.split(":");
    return t = t == null ? void 0 : t.trim(), n2 = n2 == null ? void 0 : n2.trim(), t && n2 && (o3[u(t)] = n2), o3;
  }, {});
}
function p2(e3) {
  if (Array.isArray(e3))
    return e3.map((r2) => p2(r2));
  const o3 = {
    allowfullscreen: "allowFullScreen",
    autocomplete: "autoComplete",
    autofocus: "autoFocus",
    autoplay: "autoPlay",
    charset: "charSet",
    class: "className",
    colspan: "colSpan",
    colwidth: "colWidth",
    contenteditable: "contentEditable",
    crossorigin: "crossOrigin",
    enctype: "encType",
    for: "htmlFor",
    formnovalidate: "formNoValidate",
    frameborder: "frameBorder",
    inputmode: "inputMode",
    marginheight: "marginHeight",
    marginwidth: "marginWidth",
    maxlength: "maxLength",
    minlength: "minLength",
    novalidate: "noValidate",
    playsinline: "playsInline",
    readonly: "readOnly",
    referrerpolicy: "referrerPolicy",
    rowspan: "rowSpan",
    srcset: "srcSet",
    tabindex: "tabIndex",
    targetAttr: "targetattr",
    usemap: "useMap"
  }, i6 = Object.keys(e3.props).reduce((r2, a) => {
    let s4 = e3.props[a];
    a === "style" && typeof s4 == "string" && (s4 = f(s4));
    const d = o3[a] || a;
    return r2[d] = s4, r2;
  }, {});
  i6.key = e3.key;
  const t = import_react4.default.Children.map(e3.props.children, (r2) => typeof r2 == "string" ? r2 : p2(r2));
  return import_react4.default.createElement(e3.type, i6, t);
}
var l3 = () => typeof window < "u";
var y3 = () => typeof window > "u";
var g2 = () => l3() && typeof window.storyblokRegisterEvent < "u";
var m3 = () => l3() && window.self !== window.top;
var h = () => l3() && m3() && window.location.search.includes("_storyblok");

// node_modules/@storyblok/react/dist/storyblok-rich-text.mjs
var h2 = (0, import_react5.forwardRef)(
  ({ doc: t, resolvers: r2 }, o3) => {
    const { render: e3 } = i4({
      resolvers: r2
    }), m4 = e3(t), n2 = p2(m4);
    return (0, import_jsx_runtime2.jsx)("div", { ref: o3, children: n2 });
  }
);

// node_modules/@storyblok/react/dist/index.mjs
var x2 = (s4, e3 = {}, o3 = {}) => {
  const [n2, l4] = (0, import_react6.useState)({}), i6 = typeof window < "u" && typeof window.storyblokRegisterEvent < "u", t = e2();
  return (0, import_react6.useEffect)(() => {
    if (!t) {
      console.error(
        "You can't use useStoryblok if you're not loading apiPlugin."
      );
      return;
    }
    async function y4() {
      const { data: r2 } = await t.get(
        `cdn/stories/${s4}`,
        e3
      );
      l4(r2.story), i6 && r2.story.id && qe(
        r2.story.id,
        (a) => l4(a),
        o3
      );
    }
    y4();
  }, [s4, JSON.stringify(e3), t]), t ? (o3.resolveRelations = o3.resolveRelations ?? e3.resolve_relations, o3.resolveLinks = o3.resolveLinks ?? e3.resolve_links, n2) : null;
};
var g3 = i4;
export {
  E as BlockTypes,
  w as MarkTypes,
  s2 as StoryblokComponent,
  h2 as StoryblokRichText,
  he as TextTypes,
  je as apiPlugin,
  p2 as convertAttributesInElement,
  p as getComponent,
  k as getCustomFallbackComponent,
  C as getEnableFallbackComponent,
  e2 as getStoryblokApi,
  g2 as isBridgeLoaded,
  l3 as isBrowser,
  m3 as isIframe,
  y3 as isServer,
  h as isVisualEditor,
  Be as loadStoryblokBridge,
  qe as registerStoryblokBridge,
  De as renderRichText,
  me as richTextResolver,
  b as setComponents,
  Ge as storyblokEditable,
  k2 as storyblokInit,
  x2 as useStoryblok,
  e2 as useStoryblokApi,
  qe as useStoryblokBridge,
  i4 as useStoryblokRichText,
  g3 as useStoryblokRichTextResolver,
  g as useStoryblokState
};
//# sourceMappingURL=@storyblok_react.js.map
